{"version":3,"file":"vue.js","sources":["../src/utils.js","../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["export function isFunction(val){\r\n    return typeof val === 'function'\r\n}\r\n\r\n\r\nexport function isObject(val){\r\n    return typeof val == 'object' && val !== null\r\n}\r\n\r\n\r\nexport let isArray = Array.isArray\r\n\r\n\r\n\r\n","let oldArrayPrototype = Array.prototype   //获取数组的老的原型方法\r\n\r\nexport let arrayMethods = Object.create(oldArrayPrototype)  //让arrayMethods通过__proto__ 能获取到数组的方法\r\n\r\n// 只有这七个方法可以导致数组发生变化\r\nlet methods = [\r\n    'push',\r\n    'shift',\r\n    'pop',\r\n    'unshift',\r\n    'reverse',\r\n    'sort',\r\n    'splice'\r\n]\r\nmethods.forEach(method =>{\r\n    arrayMethods[method] = function(...args){\r\n        // console.log(\"数组方法进行重写操作\")\r\n        // 数组新增的 要看一下是不是对象，如果是对象，继续进行劫持 \r\n\r\n        // 需要调用数组原生逻辑\r\n        oldArrayPrototype[method].call(this,...args)\r\n\r\n        // todo 可以添加自己逻辑 函数劫持 切片\r\n\r\n        let inserted = null\r\n        let ob =  this.__ob__\r\n        switch(method) {\r\n            case 'splice':  //修改 删除 添加  arr.splice(1,0,24)\r\n                inserted = args.slice(2) //splice方法从第三个参数起 是增添的新数据\r\n                break;\r\n            case 'push':    \r\n            case 'unshift':\r\n                inserted = args; //调用push和unshift传递的参数就是新增的逻辑\r\n                break;\r\n        }\r\n\r\n        // inserted[] 遍历数组，看一下对它是否需要进行二次劫持\r\n        if(inserted) ob.observeArray(inserted)\r\n\r\n\r\n    }\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import { isArray, isObject } from \"../utils\";\r\nimport { arrayMethods } from \"./array\";\r\n\r\n// 1. 每个对象都有一个 __proto__ 属性，它指向所属类的原型 fn.__proto__ = Function.prototype\r\n// 2. 每个原型上都有一个constructor属性指向函数本身 Function.prototype.constructor = Function\r\n\r\nclass Observe {\r\n  constructor(value) {\r\n    // 不让 __ob__ 被遍历到，不然会爆栈\r\n    // value.__ob__ = this; //我给对象和数组添加一个自定义属性 \r\n\r\n    Object.defineProperty(value,'__ob__',{\r\n      value:this,\r\n      enumerable:false, //标识这个属性不能被列举出来 不能被循环到\r\n    })\r\n\r\n\r\n    if (isArray(value)) {\r\n      // 更改数组原型方法\r\n      value.__proto__ = arrayMethods; //重写数组的方法\r\n\r\n      this.observeArray(value);\r\n    } else {\r\n      this.walk(value); //核心就是循环对象\r\n    }\r\n  }\r\n\r\n  //递归遍历数组，对数组内部的对象再次重写 [[]] [{}]\r\n  observeArray(data) {\r\n    data.forEach((item) => observe(item)); //数组里面如果是引用类型那么是响应式的\r\n  }\r\n\r\n  walk(data) {\r\n    // 要使用 definePrototype 重新定义\r\n    Object.keys(data).forEach((key) => {\r\n      defineReactive(data, key, data[key]);\r\n    });\r\n  }\r\n}\r\n\r\n// vue2 应用了defineProperty 需要一加载的时候就进行递归操作，所以耗性能，如果层次过深，也会浪费性能\r\n// 1.性能优化的原则：\r\n// 1）不要把所有的数据都防在data中，因为所有的数据都会增加get和set\r\n// 2）不要写数据的时候层次过深，尽量扁平化数据\r\n// 3）不要频繁获取数据 比如可以使用变量缓存\r\n// 4）如果数据不需要响应式，可以使用 Object.freeze 冻结属性\r\n\r\n// vue2 慢的主要原因在这个方法中\r\nfunction defineReactive(obj, key, value) {\r\n  observe(value); //递归进行观测数据，不管有多少层，都进行 defineProperty\r\n  Object.defineProperty(obj, key, {\r\n    get() {\r\n      return value; //闭包 此value会像上层的value进行查找\r\n    },\r\n    set(newValue) {\r\n      // 如果设置的是一个对象那么会再次进行劫持\r\n      if (newValue === value) return;\r\n      observe(newValue);\r\n      value = newValue;\r\n    },\r\n  });\r\n}\r\n\r\nexport function observe(value) {\r\n  // 如果value不是对象，则不用观测了\r\n  if (!isObject(value)) {\r\n    return;\r\n  }\r\n\r\n  if(value.__ob__){\r\n    return; //一个对象不需要重新被观测 \r\n  }\r\n\r\n\r\n  // 需要对对象进行观测，最外层必须是一个 { } 不能是数组\r\n\r\n  // 如果一个数据已经被观测过了，就不要在进行观测了，用类来实现，我观测过就增加一个标识， 说明观测过了，在观测的时候可以先检测是否观测过，如果观测过了就跳过检测\r\n\r\n  return new Observe(value);\r\n}\r\n","import { observe } from \"./observe\"; //rollup-plugin-node-resolve\r\nimport { isFunction } from \"./utils\";\r\n\r\nexport function initState(vm) {\r\n  const opts = vm.$options;\r\n\r\n  if (opts.data) {\r\n    initData(vm);\r\n  }\r\n}\r\n\r\n// 取值的时候做代理 不是暴力的把_data属性赋予给vm,而且直接赋值会有命名冲突问题\r\nfunction proxy(vm, key, source) {\r\n  Object.defineProperty(vm, key, {\r\n    get() {\r\n      return vm[source][key];\r\n    },\r\n    set(newValue) {\r\n      vm[source][key] = newValue; //vm._data.message = newValue 这个 _data 就是传过来的值\r\n    },\r\n  });\r\n}\r\n\r\n// 数据的初始化\r\nfunction initData(vm) {\r\n  // 用户传入的数据\r\n  let data = vm.$options.data;\r\n\r\n  // 如果用户传递的是一个函数，则取函数的返回值作为对象，如果就是对象那就直接使用这个对象\r\n\r\n  // data 和 vm._data 引用的是同一个人， data 被劫持了， vm._data也被劫持\r\n  // vm._data 是为了外面可以拿到\r\n  data = vm._data = isFunction(data) ? data.call(vm) : data;\r\n\r\n  // 需要将 data 变成响应式的 Object.defineProperty 重写data中的所有属性\r\n  observe(data); //观测数据\r\n\r\n  // vm.message = vm._data.message  _data就是一个字符串\r\n  for (let key in data) {\r\n    proxy(vm, key, \"_data\"); //代理vm上的取值和设置值 和 vm._data没关系了\r\n  }\r\n\r\n  data.arr.push(100);\r\n}\r\n","import {initState} from './state'\r\n\r\nexport function initMixin(Vue){\r\n    Vue.prototype._init = function(options){\r\n        const vm = this\r\n\r\n        // 把用户的选项放到vm上，这样在其他方法中就可以获取到options了\r\n        vm.$options = options //为了后续扩展的方法都可以获取到 options 选项\r\n\r\n        // options中是用户传入的数据 el data\r\n        initState(vm)\r\n\r\n        if(vm.$options.el){\r\n        // 要将数据挂载到页面上 \r\n\r\n        // 现在数据已经被劫持了 数据变化需要更新视图 diff算法更新需要更新的部分\r\n        //vue -> template    jsx->(灵活)\r\n        // vue3 template 写起来性能会更高一些 内部做了很多优化\r\n\r\n        // template -> ast语法树 (用来描述语法的，描述语法本身的) -> 描述成一个树结构 -> 将代码重组js语法\r\n        // 模板编译原理（把template模板编译成render函数 -> 虚拟DOM -> diff算法比对虚拟DOM ）\r\n\r\n        // ast -> render返回 —> vnode ->生成真实dom\r\n        //        更新的时候再次调用render -> 新的 vnode -> 新旧对比 -> 更新真实dom\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n}\r\n\r\n","import {initMixin} from './init'\r\n\r\n// vue要如何实现，原型模式，所有的功能都通过 原型拓展的方式来添加\r\nfunction Vue(options){\r\n    // console.log(options) \r\n    // 实现vue的初始化功能\r\n    this._init(options)\r\n}\r\n\r\ninitMixin(Vue)\r\n\r\n\r\n// 导出Vue\r\nexport default Vue\r\n\r\n\r\n// 1.new Vue 会调用_init 方法进行初始化操作\r\n// 2.会将用户的选项放在 vm.$options 上\r\n// 3.会对当前属性上搜索有没有data数据， initState\r\n// 4.有 data 判断data是不是一个函数，如果是函数取返回值initData\r\n// 5.observe 去观测data中的数据 和 vm 没关系，说明data已经变成了响应式\r\n// 6.vm上像取值也能取到data中的数据 vm._data = data 这样用户能取到data了\r\n// 7.用户觉得有点麻烦， vm.xxx => vm._data\r\n\r\n\r\n// 8.如果更新对象不存在的属性，会导致视图不更新，如果是数组更新索引和长度不会触发更新\r\n// 9.如果是替换成一个新对象，新对象会被劫持；如果是数组存放新内容 push unshift() 新增的内容也会被劫持 \r\n// 通过 __ob__ 进行标识这个对象被监控过，（在vue中被监控的对象身上都有一个__ob__属性）\r\n// 10.如果你想改索引，可以使用 $set方法，内部就是splice()\r\n\r\n\r\n// 如果有el需要挂载到页面上\r\n\r\n"],"names":["isFunction","val","isObject","isArray","Array","oldArrayPrototype","prototype","arrayMethods","Object","create","methods","forEach","method","args","call","inserted","ob","__ob__","slice","observeArray","Observe","constructor","value","defineProperty","enumerable","__proto__","walk","data","item","observe","keys","key","defineReactive","obj","get","set","newValue","initState","vm","opts","$options","initData","proxy","source","_data","arr","push","initMixin","Vue","_init","options","el"],"mappings":"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"}