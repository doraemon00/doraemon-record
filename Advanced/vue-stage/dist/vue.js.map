{"version":3,"file":"vue.js","sources":["../src/utils.js","../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["export function isFunction(val){\r\n    return typeof val === 'function'\r\n}\r\n\r\n\r\nexport function isObject(val){\r\n    return typeof val == 'object' && val !== null\r\n}\r\n\r\n\r\nexport let isArray = Array.isArray\r\n\r\n\r\n\r\n","let oldArrayPrototype = Array.prototype   //获取数组的老的原型方法\r\n\r\nexport let arrayMethods = Object.create(oldArrayPrototype)  //让arrayMethods通过__proto__ 能获取到数组的方法\r\n\r\n// 只有这七个方法可以导致数组发生变化\r\nlet methods = [\r\n    'push',\r\n    'shift',\r\n    'pop',\r\n    'unshift',\r\n    'reverse',\r\n    'sort',\r\n    'splice'\r\n]\r\nmethods.forEach(method =>{\r\n    arrayMethods[method] = function(){\r\n        // console.log(\"数组方法进行重写操作\")\r\n    }\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import { isArray, isObject } from \"../utils\";\r\nimport { arrayMethods } from \"./array\";\r\n\r\n// 1. 每个对象都有一个 __proto__ 属性，它指向所属类的原型 fn.__proto__ = Function.prototype\r\n// 2. 每个原型上都有一个constructor属性指向函数本身 Function.prototype.constructor = Function\r\n\r\n\r\n\r\nclass Observe {\r\n  constructor(value) {\r\n    if (isArray(value)) {\r\n        // 更改数组原型方法\r\n        value.__proto__ = arrayMethods; //重写数组的方法\r\n    } else {\r\n      this.walk(value); //核心就是循环对象\r\n    }\r\n  }\r\n\r\n  walk(data) {\r\n    // 要使用 definePrototype 重新定义\r\n    Object.keys(data).forEach((key) => {\r\n      defineReactive(data, key, data[key]);\r\n    });\r\n  }\r\n}\r\n\r\n// vue2 应用了defineProperty 需要一加载的时候就进行递归操作，所以耗性能，如果层次过深，也会浪费性能\r\n// 1.性能优化的原则：\r\n// 1）不要把所有的数据都防在data中，因为所有的数据都会增加get和set\r\n// 2）不要写数据的时候层次过深，尽量扁平化数据\r\n// 3）不要频繁获取数据 比如可以使用变量缓存\r\n// 4）如果数据不需要响应式，可以使用 Object.freeze 冻结属性\r\n\r\n// vue2 慢的主要原因在这个方法中\r\nfunction defineReactive(obj, key, value) {\r\n  observe(value); //递归进行观测数据，不管有多少层，都进行 defineProperty\r\n  Object.defineProperty(obj, key, {\r\n    get() {\r\n      return value; //闭包 此value会像上层的value进行查找\r\n    },\r\n    set(newValue) {\r\n      if (newValue === value) return;\r\n      value = newValue;\r\n    },\r\n  });\r\n}\r\n\r\nexport function observe(value) {\r\n  // 如果value不是对象，则不用观测了\r\n  if (!isObject(value)) {\r\n    return;\r\n  }\r\n\r\n  // 需要对对象进行观测，最外层必须是一个 { } 不能是数组\r\n\r\n  // 如果一个数据已经被观测过了，就不要在进行观测了，用类来实现，我观测过就增加一个标识， 说明观测过了，在观测的时候可以先检测是否观测过，如果观测过了就跳过检测\r\n\r\n  return new Observe(value);\r\n}\r\n","import { observe } from \"./observe\"; //rollup-plugin-node-resolve\r\nimport { isFunction } from \"./utils\";\r\n\r\nexport function initState(vm) {\r\n  const opts = vm.$options;\r\n\r\n  if (opts.data) {\r\n    initData(vm);\r\n  }\r\n}\r\n\r\n// 取值的时候做代理 不是暴力的把_data属性赋予给vm,而且直接赋值会有命名冲突问题\r\nfunction proxy(vm, key, source) {\r\n  Object.defineProperty(vm, key, {\r\n    get() {\r\n      return vm[source][key];\r\n    },\r\n    set(newValue) {\r\n      vm[source][key] = newValue; //vm._data.message = newValue 这个 _data 就是传过来的值\r\n    },\r\n  });\r\n}\r\n\r\n// 数据的初始化\r\nfunction initData(vm) {\r\n  // 用户传入的数据\r\n  let data = vm.$options.data;\r\n\r\n  // 如果用户传递的是一个函数，则取函数的返回值作为对象，如果就是对象那就直接使用这个对象\r\n\r\n  // data 和 vm._data 引用的是同一个人， data 被劫持了， vm._data也被劫持\r\n  // vm._data 是为了外面可以拿到\r\n  data = vm._data = isFunction(data) ? data.call(vm) : data;\r\n\r\n  // 需要将 data 变成响应式的 Object.defineProperty 重写data中的所有属性\r\n  observe(data); //观测数据\r\n\r\n  // vm.message = vm._data.message  _data就是一个字符串\r\n  for (let key in data) {\r\n    proxy(vm, key, \"_data\"); //代理vm上的取值和设置值 和 vm._data没关系了\r\n  }\r\n\r\n  data.arr.push(100);\r\n}\r\n","import {initState} from './state'\r\n\r\nexport function initMixin(Vue){\r\n    Vue.prototype._init = function(options){\r\n        const vm = this\r\n\r\n        // 把用户的选项放到vm上，这样在其他方法中就可以获取到options了\r\n        vm.$options = options //为了后续扩展的方法都可以获取到 options 选项\r\n\r\n        // options中是用户传入的数据 el data\r\n        initState(vm)\r\n\r\n        if(vm.$options.el){\r\n        // 要将数据挂载到页面上 \r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n}\r\n\r\n","import {initMixin} from './init'\r\n\r\n// vue要如何实现，原型模式，所有的功能都通过 原型拓展的方式来添加\r\nfunction Vue(options){\r\n    // console.log(options) \r\n    // 实现vue的初始化功能\r\n    this._init(options)\r\n}\r\n\r\ninitMixin(Vue)\r\n\r\n\r\n// 导出Vue\r\nexport default Vue\r\n\r\n\r\n// 1.new Vue 会调用_init 方法进行初始化操作\r\n// 2.会将用户的选项放在 vm.$options 上\r\n// 3.会对当前属性上搜索有没有data数据， initState\r\n// 4.有 data 判断data是不是一个函数，如果是函数取返回值initData\r\n// 5.observe 去观测data中的数据 和 vm 没关系，说明data已经变成了响应式\r\n// 6.vm上像取值也能取到data中的数据 vm._data = data 这样用户能取到data了\r\n// 7.用户觉得有点麻烦， vm.xxx => vm._data\r\n\r\n\r\n\r\n// 如果有el需要挂载到页面上\r\n\r\n"],"names":["isFunction","val","isObject","isArray","Array","oldArrayPrototype","prototype","arrayMethods","Object","create","methods","forEach","method","Observe","constructor","value","__proto__","walk","data","keys","key","defineReactive","obj","observe","defineProperty","get","set","newValue","initState","vm","opts","$options","initData","proxy","source","_data","call","arr","push","initMixin","Vue","_init","options","el"],"mappings":"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"}